= buddy documentation
Andrey Antukh, <niwi@niwi.be>
0.3.0-SNAPSHOT
:toc: left
:numbered:
:source-highlighter: pygments
:pygments-style: friendly
:sectlinks:


== Introduction

_buddy_ is a complete security library for clojure with support for:

- authentication, authorization & access rules (ring/compojure extensions)
- secure hash functions (digest)
- password hashing algorithms (bcrypt, pbkdf2, scrypt)
- message/text signing (high level interface)
- signature & authentication (mac & digital signature)
- encryption (block & stream ciphers)
- key derivartion functions (kdf)

Obviously backed by battle tested link:http://www.bouncycastle.org/specifications.html[bouncy castle]
library.

link:api/index.html[API reference documentation.]


== Project Maturity

Since _buddy_ is a young project there can be some API breakage.


== Install

This section covers installing _buddy_.


=== Requirements

_buddy_ has support for these jvm versions:

- JDK7
- JDK8


=== Leiningen

The simplest way to use _buddy_ in a Clojure project is by including
it as a dependency in your *_project.clj_*:

._in project.clj_
[source,clojure]
----
[buddy "0.3.0-SNAPSHOT"]
----

=== Maven

Also, you can use it with maven. First, add the clojars repository:

[source,xml]
----
<repository>
    <id>clojars.org</id>
    <url>http://clojars.org/repo</url>
</repository>
----

Then for buddy:

[source,xml]
----
<dependency>
    <groupId>buddy</groupId>
    <artifactId>buddy</artifactId>
    <version>0.3.0-SNAPSHOT</version>
</dependency>
----


=== Get the Code

_buddy_ is open source and can be found on link:https://github.com/niwibe/buddy[github].

You can clone the public repository with this command:

[source,text]
----
git clone https://github.com/niwibe/buddy
----

== Common Web Security

=== Generic Message Signing

The "signing framework" of _buddy_ is mainly based on django's
link:https://docs.djangoproject.com/en/1.6/topics/signing/[Cryptographic
signing] library but extended with various signing algorithms and cryptography
support.

It can be used for several purposes:

- Safely send/store signed or encrypted messages.
- Safely store session data in cookies instead of a database (this prevents others
  from changing session content)
- Self contained token generation for use with completely stateless token based authentication.

.Supported Algorithms
[options="header"]
|=====================================================================================
|Algorithm name     | Hash algorithms   | Keywords           | Priv/Pub Key?
|Elliptic Curve DSA | sha256, sha512    | `:es256`, `:es512` | Yes
|RSASSA PSS         | sha256, sha512    | `:ps256`, `:ps512` | Yes
|RSASSA PKCS1 v1_5  | sha256, sha512    | `:rs256`, `:rs256` | Yes
|HMAC               | sha256*, sha512   | `:hs256`, `:hs256` | No
|=====================================================================================

+++*+++ indicates the default value.

[NOTE]
====
Only HMAC based algorithms support plain text secret keys, If you want to use
Digital Signature instead of hmac then you must have a key pair (public and private).
====

==== Using low level api

There are four signing functions in _buddy.sign.generic_ namespace: _sign_,
_unsign_, _loads_ and _dumps_.

_sign_ and _unsign_ are low level and work primarily with strings.

.Using low level api example.
[source,clojure]
----
(require '[buddy.sign.generic :refer [sign unsign]])

;; Sign data
(def signed-data (sign "mystring" "my-secret-key"))

;; signed-data should contain a string similar to:
;; "mystring:f08dd937a438f43639d34a345910148cb933ea8ea0c2c306e8733e0255677e3d:MTM..."

;; Unsign previosly signed data
(def unsigned-data (unsign signed-data "my-secret-key"))

;; unsigned-data should contain the original string: "mystring"
----

Each signature has a timestamp attached (with millisecond of accuracy) so you can
invalidate signed messages based on their age.

.Unsign old signed data with _max-age_ parameter.
[source,clojure]
----
(unsign old-signed-data "my-secret-key" {:max-age (* 15 60)})
;; => nil
----


==== Protecting complex data structures

If you wish to protect a native data structure (hash-map, hash-set, list, vector, etc...)
you can do so using the _dumps_ and _loads_ functions.


.Using high-level api for sign and unsing complex data.
[source,clojure]
----
(require '[buddy.sign.generic :refer [dumps loads]])

;; Sign data
(def signed-data (dumps {:userid 1} "my-secret-key"))

;; signed-data should contain a string similar to:
;; "TlBZARlgGwAAAAIOAAAABnVzZXJpZCsAAAAAAAAAAQ:59d9e8063ad80f6abd3092b45857810b10f5..."

;; Unsign previously signed data
(loads signed-data "my-secret-key")
;; => {:userid 1}
----

NOTE: it uses a Clojure serialization library link:https://github.com/ptaoussanis/nippy[Nippy]


==== Using Digital Signature algorithms

In order to use any of digital signature algorithms you must have a private/public key. If you
don't have one, don't worry - it's very easy to generate it using *openssl*.

.Example on how to generate one Elliptic Curve DSA keypair.
[source, bash]
----
# Generating params file
openssl ecparam -name prime256v1 -out ecparams.pem

# Generate a private key from params file
openssl ecparam -in ecparams.pem -genkey -noout -out ecprivkey.pem

# Generate a public key from private key
openssl ec -in ecprivkey.pem -pubout -out ecpubkey.pem
----

.Example on how to generate one RSA keypair.
[source, bash]
----
# Generate aes256 encrypted private key
openssl genrsa -aes256 -out privkey.pem 2048

# Generate public key from previously created private key.
openssl rsa -pubout -in privkey.pem -out pubkey.pem
----

===== Using Digital Signature Keys for signing

Now, having generated a key pair, you can sign your messages using one
of supported digital signature algorithms.

.Example of signing a string using _es256_ (eliptic curve dsa) algorithm.
[source, clojure]
----
(require '[buddy.sign.generic :refer [sign unsign]])

;; Import namespace for managing/reading keys
(require '[buddy.core.keys :as keys])

;; Create keys instances
(def ec-privkey (keys/private-key "ecprivkey.pem"))
(def ec-pubkey (keys/public-key "ecpubkey.pem"))

;; Use them like plain secret password with hmac algorithms for sign
(def signed-data (sign "mystring" ec-privkey {:alg :es256}))

;; And unsign
(def unsigned-data (unsign signed-data ec-pubkey {:alg :es256}))
----

[[jws]]
=== Json Web Signature/Token

[small]#New in version: 0.2#

JSON Web Signature (JWS) represents content secured with digital
signatures or Message Authentication Codes (MACs) using JavaScript
Object Notation (JSON) as serialization format.

List of rfcs related to this feature:

- http://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32
- http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-38
- http://tools.ietf.org/html/draft-ietf-jose-json-web-signature-38


.Supported Algorithms
[options="header"]
|=====================================================================================
|Algorithm name     | Hash algorithms   | Keywords           | Priv/Pub Key?
|Elliptic Curve DSA | sha256, sha512    | `:es256`, `:es512` | Yes
|RSASSA PSS         | sha256, sha512    | `:ps256`, `:ps512` | Yes
|RSASSA PKCS1 v1_5  | sha256, sha512    | `:rs256`, `:rs256` | Yes
|HMAC               | sha256*, sha512   | `:hs256`, `:hs256` | No
|=====================================================================================


==== Signing and unsignin data

Due to the nature of the storage format, the input is restricted mainly to json objects
in the current version.

.Example sign data using JWS
[source, clojure]
----
(require '[buddy.sign.jws :as jws])

;; Sign data using default `:hs256` algorithm that does not
;; requres special priv/pub key.
(def data (jws/sign {:userid 1} "secret"))

;; data should contain string similar to:
;; "eyJ0eXAiOiJKV1MiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyaWQiOjF9.zjenOuIAEG-..."

(jws/unsign data "secret")
;; => {:userid 1}
----


=== Password Hashers

Another important part of a good authentication/authorization library
is providing some facilities for generating secure passwords.

.Supported password hashers algorithms
[options="header"]
|===========================================================================
| Hash algorithm name  | Namespace              | Observations
| Bcrypt               | `buddy.hashers.bcrypt` | Recommended
| Pbkdf2               | `buddy.hashers.pbkdf2` | Recommended
| Scrypt               | `buddy.hashers.scrypt` | Recommended
| sha256               | `buddy.hashers.sha256` | Not recommended
| md5                  | `buddy.hashers.md5`    | Broken! Not Recommended
|===========================================================================

A hasher consists in two functions: _make-password_ and _check-password_. The
purpose of these functions is obvious: creating a new password, and verifying
incoming plain text password with the previously created hash.

.Example of creating and verifying a new hash
[source,clojure]
----
(require '[buddy.hashers.bcrypt :as hs])

(def myhash (hs/make-password "secretpassword"))
(def ok (hs/check-password "secretpassword" myhash))

;; ok var reference should contain true
----

NOTE: hasher functions, unlike cryptographic hash functions, expect strings instead
of bytes.

NOTE: _make-password_ function options may vary depending of hasher algorithm is used.


== Auth "`framework`".

Additionally, buddy commes with authentication and authorization "`framework`"
for ring based web apps.


=== Authentication

Buddy differs with other libraries because it takes very different approach for handling
authentication. Firstly, it clearly split authentication and authorization in two
separate steps. Secondly, it implements it using "`backends`" and protocols for easy
extensibility.

If you are not happy with builtin backends, you can implement your own and use it with
buddy middlewares without any problem.

Authentication in buddy, has two phases:

- *parse*: parsing incoming request headers, parameters etc...
- *authenticate*: having parsed data do authentication process, such as call auth function,
  unsign self contained token, etc...

.Here is a list of built-in authentication backends:
[options="header"]
|================================================
| Backend name | Namespace
| Http Basic   | `buddy.auth.backends.httpbasic`
| Session      | `buddy.auth.backends.session`
| Token        | `buddy.auth.backends.token`
| SignedToken  | `buddy.auth.backends.token`
|================================================


==== HTTP Basic

The HTTP Basic authentication backend is one of the simplest and most insecure authentication
systems, but is a good first step for understand how buddy authentication works.

.Simple ring handler/view for example purpose.
[source,clojure]
----
(require '[buddy.auth :refer (authenticated?)])
(require '[ring.util.response :refer (response)])

;; Simple ring handler. This can also be a compojure router handler
;; or anything else compatible with ring middlewares.
(defn handler
  [request]
  (if (authenticated? request)
    (response (format "Hello %s" (:identity request)))
    (response "Hello Anonymous")))
----

.Create an instance of authentication backend.
[source, clojure]
----
(require '[buddy.auth.backends.httpbasic :refer [http-basic-backend]])

;; Http Basic backend in this case requires one function with parameter
;; that takes a responsability to identify the incoming request.

;; The required function is caled in authentication of parsed data
;; and it receives the current ring request and parsed data from parse
;; phase of authentication.
;;
;; This function should return a non-nil value that
;; is automatically stored on :identity key on request
;; If it returns nil, a request is considered unauthenticated.

(defn my-authfn
  [request, authdata]
  (let [username (:username authdata)
        password (:password authdata)]
    username))

(def backend (http-basic-backend {:realm "MyApi" :authfn my-authfn}))
----


Now having simple view function and backend defined, you should wrap it
using the  standard ring middleware way, with buddy's authentication middleware.

.Declare auth function and create ring app with wrapped handler.
[source,clojure]
----
(require '[buddy.auth.middleware :refer [wrap-authentication]])

;; Define the main handler with *app* name wrapping it
;; with authentication middleware using an instance of
;; just created http-basic backend.

;; Define app var with handler wrapped with buddy's authentication
;; middleware using just previously defined backend.

(def app (wrap-authentication handler backend))
----

Now, all incoming requests with basic auth header are properly parsed and
requests with `:identity` forwarded to real handler or next middleware.


==== Session

The session backend has the simplest implementation because it relies
entirely on ring session support.

It checks the `:identity` key in the session to authenticate the user with its
value. The value is identified as logged-in user if it contains any logical true
value.

See xref:examples[examples section] for complete examples for this backend.


==== Token

===== Standard

This backend works much like the basic auth backend with the difference that this works with
tokens that can be unpredictable.

It parses a token and passes it to _authfn_ for authentication.


===== Signed/Stateless

This backend is very similar to standard token backend previously explained, but instead
of relying on _authfn_ for identify a token, it uses stateless tokens (contains all needed
data in a token, without storing any information about token on database as ex...).

This backend relies on the security of the high level signing framework for user authentication.

Reference: http://lucumr.pocoo.org/2013/11/17/my-favorite-database/


=== Authorization

An other part of auth process is the authorization.

==== Introduction

The authorization system is split into two parts: generic authorization and access-rules
(explained in other section).

The generic authorization consists in raising one specific exception in a ring handler for
indicate the unauthorized access. It is less functional, but in some circumstances can work
very well.


==== How does it work?

It is very simple, the authorization backend wraps everything in a try/catch block only
watching for specific exception, and in case of unauthorized exception is intercepted,
executes a specific function for handle it or reraise the exception.

With this approach you can define your own middlewared/decorators using custom authorization
logic with fast skip raising not authorized exception using the `throw-unauthorized` function.

.Example ring handler raising unauthorized exception.
[source, clojure]
----
(require '[buddy.auth :refer [authenticated? throw-unauthorized]])
(require '[ring.util.response :refer (response redirect)])

(defn home-controller
  [request]
  (when (not (authenticated? request))
    (throw-unauthorized {:message "Not authorized"}))
  (response "Hello World"))
----

Like authentication system, authorization is also implemented using protocols. Taking advantage of
it, all built-in authentication backends also implement this authorization protocol (`IAuthorization`):

[NOTE]
====
Some authentication backends require specific behavior in the authorization layer (like http-basic
which should return `WWW-Authenticate` header when request is unauthorized). By default, all backends
come with an specific implementation.

You can overwrite the default behavior by passing your own exception handler through the
`:unauthorized-handler` keyword parameter in the backend constructor.
====

Below is a complete example setting up a basic/generic authorization
system for your ring compatible web application:

.Define the final handler
[source,clojure]
----
(require '[buddy.auth.backends.httpbasic :refer [http-basic-backend]])
(require '[buddy.auth.middleware :refer [wrap-authentication wrap-authorization]])

;; Define the final handler wrapping it on authentication and
;; authorization handler using the same backend and overwriting
;; the default unathorized request behavior with own, previously
;; defined function

(def app
  (let [backend (http-basic-backend
                 {:realm "API"
                  :authfn my-auth-fn
                  :unauthorized-handler my-unauthorized-handler})]
    (-> handler
        (wrap-authentication backend)
        (wrap-authorization backend))))
----

If you want to know how it really works, see xref:how-auth-works[How auth works] section or
take a look on examples.


[[access-rules]]
=== Access Rules

==== Introduction

The access rules system is another part of the authorization, and it consists in match a url to
specific access rule logic.

The access rules consists in one ordered list, with mappings between urls and rule handler using
link:https://github.com/weavejester/clout[clout] url matching syntax o regular expressions.

.This is an example of one access rule using clout syntax.
[source, clojure]
----
[{:uri "/foo"
  :handler user-access}
----

.The same example but using regular expressions.
[source, clojure]
         ----
[{:pattern #"^/foo$"
  :handler user-access}
----

==== Rules Handlers

The rule handler, as unit of work is a plain function that accepts
request as parameters and should return `accessrules/success` or `accessrules/error`.

The `success` is a simple mark that means that handles passes the validation
and `error` is a mark that means the opposite, that the handler does not pases
the validation. Instead of returning plain boolean value, this approach allows
to handlers return errors messages or even an ring response.

.This is a simple example of the aspect of one rule handler
[source, clojure]
----
(require '[buddy.auth :refer (authenticated?)])
(require '[buddy.auth.accessrules :refer (success error)])

(defn authenticated-user
  [request]
  (if (authenticated? request)
    true
    (error "Only authenticated users allowed")))
----

This values are considered success marks: *true* and *success* instance. And that ones are
considered error marks: *nil*, *false*, *error* instance. Error instances can contain
a string as error message or ring response hash-map.

Also, a rule handler can be a composition of few ones using logical operators.

.This is the aspect of composition of rule-handlers
[source, clojure]
----
{:and [authenticated-user admin-user]}
{:or [authenticated-user admin-user]}
----

.Logical expressions can be nestest as deep as you want.
[source, clojure]
----
{:or [should-be-admin
      {:and [should-be-safe
             should-be-authenticated]}]}}
----

.This is an example of how an composed rule handler can be used in an access rule.
[source, clojure]
----
[{:pattern #"^/foo$"
  :handler {:and [authenticated-user admin-user]}}]
----


==== Usage

Now, knowing how rules can be defined, the question is: "`How can we use
it for access control for my routes?`"

Buddy exposes two ways to do it:

- Using a _wrap-access-rules_ middleware and define a decoupled
  list access rules.
- Using a _restrict_ decorator for set specific rules handlers to concrete
  ring handler.

Here are comple examples of how we can done it:

.Using _wrap-access-rules_ middleware.
[source,clojure]
----
;; Rules handlers used on this example are omited for code clarity
;; and them repsents a authorization logic for its name.

(def rules [{:pattern #"^/admin/.*"
             :handler {:or [admin-access operator-access]}}
            {:pattern #"^/login$"
             :handler any-access}
            {:pattern #"^/.*"
             :handler authenticated-access}])

;; Define default behavior for not authorized requests
;;
;; This functions works like default ring compatible handler
;; and should implement the default behavior for request
;; that are not authorized by any defined rule

(defn on-error
  [request value]
  {:status 403
   :headers {}
   :body "Not authorized"})

;; Wrap your handler with access rules (and run with jetty as example)
(defn -main
  [& args]
  (let [options {:rules rules :on-error on-error}
        app     (wrap-access-rules your-app-handler options)]
    (run-jetty app {:port 9090}))
----

If request uri does not match any regular expression then the default policy is used
Default policy in buddy is *allow* but you can change the default behavior
specify `:reject` value to `:policy` option.

Additionally, instead of specify the global _on-error_ handler, you can set a specific
behavior on specific access rule, o use the _:redirect_ option for simply redirect
a user to specific url.

.Let see an example.
[source,clojure]
----
(def rules [{:pattern #"^/admin/.*"
             :handler {:or [admin-access operator-access]}
             :redirect "/notauthorized"}
            {:pattern #"^/login$"
             :handler any-access}
            {:pattern #"^/.*"
             :handler authenticated-access
             :on-error (fn [req _] (response "Not authorized ;)"))}])
----

The access rule options are always has more preference that global ones.


If you don't want an external rules list and simple want apply some rules to specific
ring views/handlers, your can use `restrict` decorator.


.Using _restrict_ decorator.
[source, clojure]
----
(require '[buddy.auth.accessrules :refer [restrict]])

(defn home-controller
  [request]
  {:body "Hello World" :status 200})

(defroutes app
  (GET "/" [] (restrict home-controller {:handler should-be-authenticated
                                         :on-error on-error}))
----


== Cryptographic Api

Buddy has a low-level interface and a high-level interface.

The low-level interface is located in the `buddy.core` namespace and
has implementations for:

- cryptographic hash algorithms
- key derivation algorithms
- digital signatures
- message authentication (mac)
- cryptographic algorithms (block & stream ciphers)


=== Cryptographic hash algorithms

All hash algorithms are located in the `buddy.core.hash` namespace.

.Available hash algorithms
[options="header"]
|===============================================
| Hash algorithm name  | Digest size
| SHA1                 | 160
| SHA2                 | 256, 384, 512
| SHA3                 | 256, 384, 512
| MD5                  | 128
| Tiger                | 192
|===============================================


==== Basic usage

.Import namespace example:
[source, clojure]
----
(require '[buddy.core.hash :as hash])
(require '[buddy.core.codecs :refer :all])
----

.Usage examples:
[source, clojure]
----
(hash/sha256 "foo bar")
;; -> #<byte[] [B@162a657e>

(-> (hash/sha256 "foo bar")
    (bytes->hex))
;; -> "fbc1a9f858ea9e177916964bd88c3d37b91a1e84412765e29950777f265c4b75"
----


==== Advanced usage

Hash functions are implemented using protocols and can be extended
to other types. The default implementations come with support
for file-like objects (*File*, *URL*, URI* and *InputStream*).

.Make hash of file example:
[source, clojure]
----
;; Additional import for easy open files
(require '[clojure.java.io :as io])

(-> (hash/sha256 (io/input-stream "/tmp/some-file"))
    (bytes->hex))
;; -> "bba878639499c8449f69efbfc699413eebfaf41d4b7a7faa560bfaf7e93a43dd"
----

You can extend it for your own types using the
*buddy.core.hash/Digest* protocol:

[source,clojure]
----
(defprotocol Digest
  (make-digest [data algorithm]))
----

[NOTE]
Functions like *sha256* are aliases for the more generic
function *digest*.


=== Mac algorithms

Buddy comes with three mac implementations: *HMac*, *SHMac* and *Poly1305*.

==== HMac & SHMac

There are two variants of hmac: simple and salted. Both are available
in the `buddy.core.mac.hmac` and `buddy.core.mac.shmac` respectively.

===== Basic usage

[source, clojure]
----
;; Import required namespaces
(require '[buddy.core.mac.hmac :as hmac])
(require '[buddy.core.mac.shmac :as shmac])
(require '[buddy.core.codecs :refer :all])

;; Generate sha256 hmac over string
(-> (hmac/hmac "foo bar" "mysecretkey" :sha256)
    (bytes->hex))
;; -> "61849448bdbb67b39d609471eead667e65b0d1b9e01b1c3bf7aa56b83e9c8083"

;; Same example but using salted variant
(-> (shmac/shmac "foo bar" "salt" "mysecretkey" :sha256)
    (bytes->hex))
;; -> "bd5f7a0040430a73f4845bac8f980c6398b4baae8a22efcc22038be0f4dd9678"
----

The key parameter can be any type that implements the *ByteArray* protocol
defined in the `buddy.core.codecs` namespace. It comes with default implementations for
`byte[]` and `java.lang.String`.


===== Advanced usage

Like hash functions, hmac is implemented using Clojure
protocols and comes with default implementations for: String, byte[],
*File*, *URL*, *URI* and *InputStream*.

[source,clojure]
----
(require '[clojure.java.io :as io])

;; Generate hmac for file
(-> (io/input-stream "/tmp/somefile")
    (hmac/hmac "mysecretkey" :sha256)
    (bytes->hex))
;; -> "4cb793e600848da2053238003fce4c010233c49df3e6a04119b4287eb464c27e"
----

You can extend it for your own types using `buddy.core.mac.hmac/HMac` protocol:

[source,clojure]
----
(defprotocol HMac
  (make-hmac [data key algorithm]))
----


==== Poly1305

Poly1305 is a cryptographic message authentication code
(MAC) written by Daniel J. Bernstein. It can be used to verify the
data integrity and the authenticity of a message.

The security of Poly1305 is very close to the block cipher algorithm.
As a result, the only way for an attacker to break Poly1305 is to break
the cipher.

Poly1305 offers cipher replaceability. If anything goes wrong with
one, it can be substituted by another with identical security
guarantees.

Unlike *HMac*, it requires an initialization vector (IV). An IV is
like a salt. It should be generated using a strong random number
generator for security guarantees. Also, the IV should be of the same
length as the chosen cipher block size.


===== Basic usage

The default specification talks about AES as default block cipher,
but buddy comes with support for three block ciphers: AES, Serpent
and Twofish.

.Make mac using Serpent block cipher with random IV
[source, clojure]
----
(require '[buddy.core.codecs :refer [bytes->hex]])
(require '[buddy.core.mac.poly1305 :as poly])
(require '[buddy.core.keys :refer [make-random-bytes]])

(let [iv  (make-random-bytes 16)
      mac (poly/poly1305 "some-data" "mysecret" iv :serpent)]
  (println (bytes->hex mac)))
;; => "1976b1c490c306e7304a59dfacee4207"
----

=== Public/Private keypairs

Before explaining digital signatures, you need to read public/private
keypairs and convert them to usable objects. Buddy has limited support
for reading:

- RSA keypair
- ECDSA keypair


==== RSA Keypair

An RSA keypair is obviously used for RSA encryption/decryption, but it
is also used for making digital signatures with RSA-derived
algorithms.

.Read keys
[source,clojure]
----
(require '[buddy.core.keys :as keys])

;; The last parameter is optional and is only mandatory
;; if a private key is encrypted.
(def privkey (keys/private-key "test/_files/privkey.3des.rsa.pem" "secret")
(def pubkey (keys/public-key "test/_files/pubkey.3des.rsa.pem"))
----

.Generate a RSA Keypair using openssl.
[source,bash]
----
# Generate AES-256 encrypted private key
openssl genrsa -aes256 -out privkey.pem 2048

# Generate public key from previously created private key.
openssl rsa -pubout -in privkey.pem -out pubkey.pem
----


==== ECDSA Keypair

Like RSA keypairs, ECDSA is also used for making digital signatures
and can be read like in the RSA examples.

.Read keys.
[source, clojure]
----
(require '[buddy.core.keys :as keys])

;; The last parameter is optional and is only mandatory
;; if a private key is encrypted.
(def privkey (keys/private-key "test/_files/privkey.ecdsa.pem" "secret")
(def pubkey (keys/public-key "test/_files/pubkey.ecdsa.pem"))
----

.Generate a ECDSA Keypair using openssl.
[source, bash]
----
# Generate a params file
openssl ecparam -name prime256v1 -out ecparams.pem

# Generate a private key from params file
openssl ecparam -in ecparams.pem -genkey -noout -out ecprivkey.pem

# Generate a public key from private key
openssl ec -in ecprivkey.pem -pubout -out ecpubkey.pem
----


=== Digital Signatures

Digital Signatures differ from Mac as Mac values are both generated
and verified using the same secret key. Digital Signatures require a
public/private keypair. It signs using a private key and verifies a
signature using a public key.


==== RSASSA PSS

RSASSA-PSS is an improved probabilistic signature scheme with
appendix. What that means is that you can use a private RSA key
to sign data in combination with some random input.

link:http://www.ietf.org/rfc/rfc3447.txt[rfc3447.txt]

.Sign sample string using rsassa-pss.
[source, clojure]
----
(require '[buddy.core.keys :as keys])
(require '[buddy.core.sign.rsapss :as rsapss])

;; Read private key
(def rsaprivkey (keys/private-key "test/_files/privkey.3des.rsa.pem" "secret"))

;; Make signature
(def signature (rsapss/rsapss "foo" rsaprivkey :sha256))

;; Now signature contains a byte[] with signature of "foo" string
----

.Verify signature using rsassa-pss.
[source, clojure]
----
;; Read private key
(def rsapubkey (keys/private-key "test/_files/pubkey.3des.rsa.pem"))

;; Make verification
(rsapss/verify "foo" signature rsapubkey :sha256))
;; => true
----


==== RSASSA PKCS1 v1.5

RSASSA-PSS is an probabilistic signature scheme with appendix.
What that means is that you can use a private RSA key to sign data.

link:http://www.ietf.org/rfc/rfc3447.txt[rfc3447.txt]


.Sign sample string using rsassa-pkcs.
[source, clojure]
----
(require '[buddy.core.keys :as keys])
(require '[buddy.core.sign.rsapkcs :as rsapkcs])

;; Read private key
(def rsaprivkey (keys/private-key "test/_files/privkey.3des.rsa.pem" "secret"))

;; Make signature
(def signature (rsapkcs/rsapkcs15 "foo" rsaprivkey :sha256))

;; Now signature contains a byte[] with signature of "foo" string
----

.Verify signature using rsassa-pkcs.
[source, clojure]
----
;; Read private key
(def rsapubkey (keys/private-key "test/_files/pubkey.3des.rsa.pem"))

;; Make verification
(rsapkcs/verify "foo" signature rsapubkey :sha256))
;; => true
----


==== Eliptic Curve DSA

Elliptic Curve Digital Signature Algorithm (ECDSA) is a variant of the
Digital Signature Algorithm (DSA) which uses elliptic curve cryptography.

.Sign sample string using ecdsa.
[source, clojure]
----
(require '[buddy.core.keys :as keys])
(require '[buddy.core.sign.ecdsa :as ecdsa])

;; Read private key
(def ecdsaprivkey (keys/private-key "test/_files/privkey.ecdsa.pem" "secret"))

;; Make signature
(def signature (ecdsa/ecdsa "foo" ecdsaprivkey :sha256))
----

.Verify signature using ecdsa.
[source, clojure]
----
;; Read private key
(def ecdsapubkey (keys/private-key "test/_files/pubkey.ecdsa.pem"))

;; Make verification
(ecdsa/verify "foo" signature ecdsapubkey :sha256))
;; => true
----


=== Key Derivation Functions

Key derivation functions are often used in conjunction with non-secret parameters
to derive one or more keys from a common secret value.

*buddy* commes with several of them:

.Supported key derivation functions.
[options="header"]
|==============================================================================
|Algorithm name | Constructor              | Notes
|HKDF           | `buddy.core.kdf/hkdf`    | HMAC based KDF
|KDF1           | `buddy.core.kdf/kdf1`    |
|KDF2           | `buddy.core.kdf/kdf2`    |
|CMKDF          | `buddy.core.kdf/cmkdf`   | Counter Mode KDF
|FMKDF          | `buddy.core.kdf/fmkdf`   | Feedback Mode KDF
|DPIMKDF        | `buddy.core.kdf/dpimkdf` | Double-Pipeline Iteration Mode KDF
|==============================================================================

[NOTE]
====
All key derivation functions work with byte arrays. For the
following examples, the functions in `buddy.core.codecs` convert
strings to byte arrays.
====


==== HKDF

HMAC-based Extract-and-Expand Key Derivation Function (HKDF) is implemented according to IETF RFC 5869

.Example using hkdf
[source, clojure]
----
(require '[buddy.core.codecs :refer :all])
(require '[buddy.core.kdf :as kdf])

;; Using hkdf derivation functions. It requires a
;; key, salt and optionally info field that can
;; contain any random data.

(let [kfn (kdf/hkdf (str->bytes "mysecretkey")
                    (str->bytes "mypublicsalt")
                    nil ;; info parameter can be nil
                    :sha256)]
  (-> (kdf/generate-bytes! kfn 8)
      (bytes->hex)))
;; => "0faba553152fce4f"

----


==== KDF1/2

KDF1/2 hash-based key derivation functions for derived keys and ivs as defined by IEEE P1363a/ISO 18033.

.Example using kdf1 or kdf2
[source, clojure]
----
(require '[buddy.core.codecs :refer :all])
(require '[buddy.core.kdf :as kdf])

;; kdf1 and kdf2 are very similar and have the same
;; constructor signature. Requires: key data, salt
;; and hash algorithm keyword.

(let [kfn (kdf/kdf2 (str->bytes "mysecretkey") (str->bytes "mypublicsalt") :sha256)]
  (-> (kdf/generate-bytes! kfn 8)
      (bytes->hex)))
;; => "0faba553152fce4f"
----


==== Counter Mode KDF

Hash-based KDF with counter mode defined by the publicly available NIST SP 800-108 specification.


==== Feedback Mode KDF

Hash-based KDF with feedback mode defined by the publicly available NIST SP 800-108 specification.


==== Double-Pipeline Iteration Mode KDF

Hash-based KDF with Double-Pipeline Iteration Mode defined by the publicly available
NIST SP 800-108 specification.


=== Ciphers

Ciphers support in buddy is available on `buddy.core.crypto` namespace.


==== Block Ciphers

In cryptography, a block cipher is a deterministic algorithm operating on fixed-length groups of bits,
called blocks, with an unvarying transformation that is specified by a symmetric key.

.This is a list of currently supported block ciphers in buddy
[options="header"]
|========================================
|Algorithm name     | Keywords
| AES               | `:aes`
| Twofish           | `:twofish`
| Blowfish          | `:blowfish`
|========================================

Additionally, for good security, is mandatory to combine a block cipher with some cipher
mode of operation.

.This is a list of currently supported of cipher mode of operation
[options="header"]
|========================================
|Algorithm name     | Keywords
| SIC (CTR)         | `:ctr`, `:sic`
| CBC               | `:cbc`
| OFB               | `:ofb`
|========================================

Encrypting data using buddy's crypto primitives is almost as easy. In case of block ciphers, you
should know the block cipher and cipher mode you want to use.

NOTE: currently buddy comes with limited number of ciphers and modes, but in near future
more many more options should be added.

.Example encrypt
[source, clojure]
----
(require '[buddy.core.crypto :as c])
(require '[buddy.core.codecs :refer :all])

(let [eng   (c/engine :twofish :cbc)
      iv16  (make-random-bytes 16)
      key32 (make-random-bytes 32)
      data  (hex->bytes "000000000000000000000000000000AA")]
  (c/initialize! eng {:key key32 :iv iv16 :op :encrypt})
  (c/process-block! eng data))
;; => #<byte[] [B@efadff9>
----


==== Stream Ciphers

Stream ciphers differ from block ciphers, in that they works with arbitrary length input
and do not require any additional mode of operation.

.This is a list of currently supported of stream ciphers in buddy
[options="header"]
|========================================
|Algorithm name     | Keywords
| ChaCha           | `:chacha`
|========================================


.Example encrypt
[source, clojure]
----
(require '[buddy.core.crypto :as c])
(require '[buddy.core.codecs :refer :all])

(let [eng   (c/stream-engine :chacha)
      iv8   (make-random-bytes 8)
      key32 (make-random-bytes 32)
      data  (hex->bytes "0011")]
  (c/initialize! eng {:key key32 :iv iv8 :op :encrypt})
  (c/process-bytes! eng data))
;; => #<byte[] [B@efadff9>
----

NOTE: the iv and key size depends estrictly on cipher engine, in this case, chacha
engine requires 8 bytes iv.

NOTE: for decrypt, only change `:op` value to `:decrypt`

You can call `c/initialize` any times as you want, it simply reinitializes the engine.

=== Codecs

The codecs implement some useful functions that are widely used around all buddy library. They
consists mainly on functions related conversion between strings, bytes, hex encoded strings
and base64.

The best documentation for this part is the source code.


[[advanced]]
== Advanced Usage


[[how-auth-works]]
=== How Auth Works

Each backend implements two protocols: `IAuthentication` and `IAuthorization`.

*IAuthentication* provides two functions: `parse` and `authenticate`
and is automatically handled with `wrap-authentication` ring
middleware. This is an example flow for the http basic backend:

1. Received request is passed to the `parse` function. This function extracts the +Authorization+
   header, decodes a base64 encoded string and returns Clojure map with `:username` and `:password`
   keys. When a parse error occures then it returns nil.
2. If the previous step parsed the token successfully, `authenticate` is called with current
   request and parsed data from previous step. `authenticate` can delegate authentication
   to a user defined function passed as `:authfn` parameter to backend constructor.
   `authenticate` should return a request with the `:identity` key assigned to nil or any other
   value. All requests with `:identity` key with a nil value are considered not authenticated.
3. User handler is called.


[NOTE]
=========================
- `parse` function can return a valid response, in that case response is returned immediately
  ignoring the user handler.
- if `parse` function returns nil, `authenticate` function is ignored and user handler is
  called directly.
- `authenticate` can also can return a valid response, in this case it has same behavior that
  as the `parse` function.
=========================

*IAuthorization* provides `handle-unauthorized` function. Each backend implements it as a default
behavior but it can be overwritten with a user defined function, passed on `:handle-unauthorized`
keyword parameter to backend constructor. It should always return a valid response.

Authorization is handled automatically with `wrap-authorization` ring middleware. It wraps
all requests in try/catch block for interception by the authorization exception.

This is a flow that follows authorization middleware:

1. User handler is wrapped in try/catch block and executed.
2. Not authorized exception is raised with `buddy.auth/throw-unauthorized` function from
   any part of your handler.
3. handle-unauthorized is executed of your backend, if user has specified it own function,
   the user defined function is executed else, default behavior is executed.


== Examples

_buddy_ comes with some examples for helping a new user understand how
it works. All examples are available in the `examples/` directory.

At the moment, two examples are available:

- link:https://github.com/niwibe/buddy/tree/master/examples/sessionexample[Use session backend as authentication and authorization.]
- link:https://github.com/niwibe/buddy/tree/master/examples/oauthexample[Use session backend with oauth2 using Github api.]


To run examples, you should be in the project's root directory.
Execute `lein with-profile examplename run` where examplename can be
`sessionexample` or `oauthexample`.


== FAQ

*Buddy is a security library/framework?*

Yes and No. I don't like call "security" library because security represents a very generic
concepts and can contain a lot of things. Buddy targets cryptography, message signing
and authentication/authorization extensions for ring compatible web applications. You can see
the main target on the "Introduction" section of this documentation.

*How can I use _buddy_ with link:http://clojure-liberator.github.io/liberator/[liberator]?*

By design, _buddy_ has authorization and authentication well
separated. This helps a lot if you want use only one part of it (ex:
authentication only) without including the other.

The best combination is to use _buddy_'s authentication middleware
with liberator authorization endpoints.

*Buddy has own cryptographic algorithms implementations?*

Mainly no, I'm not cryptography expert and for this I rely on the to battle tested Bouncy Castle java
library that's dedicated to this purpose.

*Buddy will support pgp?*

Surely not! Because there already exists one good link:https://github.com/greglook/clj-pgp[library for that].

== How to Contribute?

=== Philosophy

Five most important rules:

- Beautiful is better than ugly.
- Explicit is better than implicit.
- Simple is better than complex.
- Complex is better than complicated.
- Readability counts.

All contributions to _buddy_ should keep these important rules in mind.


=== Procedure

Unlike Clojure and other Clojure contrib libs, _buddy_ does not have many
restrictions for contributions. Just follow the following steps depending on the
situation:

**Bugfix**:

- Fork the GitHub repo.
- Fix a bug/typo on a new branch.
- Make a pull-request to master.

**New feature**:

- Open new issues with the new feature proposal.
- If it is accepted, follow the same steps as "bugfix".


=== License

[source,text]
----
Copyright (c) 2014-2015, Andrey Antukh

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
----
